load "brainstorm2.m";
line1;
line1*line2/line3;
v := $1;
Parent($1);
line1, line2, line3 := HyperellipticDivisor(E3,pts);
line1*line2/line3;
v := $1;
Parent(v);
KE3!v;
v := KE3!(line1*line2/line3);
v;
Support(Divisor(v));
function MakeLine(C,P1,P2)
  // C must be a plane curve
  if IsProjective(C) then
    A<x,y> := CoordinateRing(Ambient(AffinePatch(C,1)));
  else
    assert IsAffine(C);
    A<x,y> := CoordinateRing(Ambient(C));
  end if;
  return ((P2[1] - P1[1])*(y - P1[2]) - (P2[2] - P1[2])*(x - P1[1]));
end function;
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q,-Q);
  return line1, line2, line3, line4;  
end function;
line1, line2, line3, line4; := HyperellipticDivisor(E3,pts);
line1, line2, line3, line4 := HyperellipticDivisor(E3,pts);
line4;
Divisor(line3) - Divisor(line4);
function MakeLine(C,P1,P2)
  // C must be a plane curve
  if IsProjective(C) then
    A<x,y> := CoordinateRing(Ambient(AffinePatch(C,1)));
  else
    assert IsAffine(C);
    A<x,y> := CoordinateRing(Ambient(C));
  end if;
  return ((P2[1] - P1[1])*(y - P1[2]) - (P2[2] - P1[2])*(x - P1[1]));
end function;
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q,-Q);
  lines := [line1, line2, line3, line4];
  return lines;
  //return line1, line2, line3, line4;  
end function;
lines := HyperellipticDivisor(E3,pts);
lines := [KE3!line : line in lines];
Support(Divisor(lines[3]) - Divisor(lines[4]));
v := KE3!(line1*line2/line3);
Support(Divisor(v));
pts_diff := Support(Divisor(lines[3]) - Divisor(lines[4]));
pts_v := Support(Divisor(v));
pts_diff[2];
pts_v[2];
pts_v[#pts_v];
pts_diff[2] eq pts_v[#pts_v];
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q,-Q);
  line5 := MakeLine(E,-Q,-Q_2);
  lines := [line1, line2, line3, line4, line5];
  return lines;
  //return line1, line2, line3, line4;  
end function;
lines;
Support(Divisor(lines[5]) - Divisor(lines[4]));
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q,-Q);
  line5 := MakeLine(E,-Q,-Q_2);
  lines := [line1, line2, line3, line4, line5];
  return lines;
  //return line1, line2, line3, line4;  
end function;
lines := HyperellipticDivisor(E3,pts);
lines := [KE3!line : line in lines];
Support(Divisor(lines[5]) - Divisor(lines[4]));
Support(Divisor(v));
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q/2,-Q/2);
  line5 := MakeLine(E,-Q/2,-Q_2/2);
  lines := [line1, line2, line3, line4, line5];
  return lines;
  //return line1, line2, line3, line4;  
end function;
lines := HyperellipticDivisor(E3,pts);
function HyperellipticDivisor(E,Ps)
  A<x,y> := CoordinateRing(Ambient(AffinePatch(E,1)));
  // make lines
  line1 := MakeLine(E,Ps[1],Ps[2]);
  line2 := MakeLine(E,Ps[3],Ps[4]);
  Q := -(Ps[3] + Ps[4]);
  Q_2 := Q/2;
  line3 := MakeLine(E,Q,-Q_2);
  line4 := MakeLine(E,Q,-Q);
  line5 := MakeLine(E,-Q,-Q_2);
  lines := [line1, line2, line3, line4, line5];
  return lines, Q;
  //return line1, line2, line3, line4;  
end function;
lines,Q := HyperellipticDivisor(E3,pts);
Q;
Order(Q);
Rank;
Q/2;
Q/4;
Q/6;
Degree(BaseField(E3));
AbsoluteDegree(BaseField(E3));
E;
E_leg;
MinimalWeierstrassModel(E_leg);
ReducedMinimalWeierstrassModel(E_leg);
ChangeRing(E_leg,QQ);
MinimalWeierstrassModel($1);
ChangeRing(E_leg,QQ);
MinimalModel($1);
IsIsomorphic(E,E_leg);
BaseRing(E_leg);
BaseRing(E);
ChangeRing(E_leg,QQ);
MinimalModel($1);
E_min := $1;
ChangeRing(E_min, BaseRing(E_leg));
IsIsomorphic(E,E_min);
E;
ChangeRing(E_min, BaseRing(E));
IsIsomorphic(E,E_min);
ChangeRing(E_min, BaseRing(E_leg));
ChangeRing(E_min, BaseRing(E));
IsIsomorphic(E, $1);
ChangeRing(E_min, BaseRing(E));
IsIsomorphic(E_leg, $1);
E;
MinimalModel(E);
Q;
oo;
Parent(Q);
oo := E3!0;
RiemannRochSpace(Divisor(Q/2) + Divisor(oo));
RR, mp_RR := RiemannRochSpace(Divisor(Q/2) + Divisor(oo));
b := Basis(RR);
b;
b := [mp_RR(el) : el in b];
b;
u := b[1];
Support(Divisor(u));
Support(Divisor(v));
RR, mp_RR := RiemannRochSpace(Divisor(-Q/2) + Divisor(oo));
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
u := b[1];
Support(Divisor(u));
Support(Divisor(v));
RR, mp_RR := RiemannRochSpace(Divisor(Q/2) + Divisor(oo));
b := [mp_RR(el) : el in b];
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
u := b[1];
Support(Divisor(u));
Support(Divisor(v));
RR, mp_RR := RiemannRochSpace(Divisor(-(Q/2)) + Divisor(oo));
b := [mp_RR(el) : el in b];
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
u := b[1];
Support(Divisor(u));
Support(Divisor(v));
RiemannRochSpace(Divisor(Q/2) + Divisor(oo));
RR!u;
mp_RR @@ u;
u @@ mp_RR;
Q/2;
RR, mp_RR := RiemannRochSpace(4*Divisor(Q/2) + 4*Divisor(oo));
v;
v^2 @@ mp_RR;
mp_RR;
RR;
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
RR, mp_RR := RiemannRochSpace(2*Divisor(Q/2) + 2*Divisor(oo));
b := [mp_RR(el) : el in b];
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
[Support(Divisor(el)) : el in b];
for el in b do
print Support(Divisor(el));
end for;
#b;
RR, mp_RR := RiemannRochSpace(4*Divisor(Q/2) + 4*Divisor(oo));
v;
Support(Divisor(v));
v^2 @@ mp_RR;
RiemannRochSpace(4*Divisor(Q/2) + 4*Divisor(oo));
RR, mp_RR := RiemannRochSpace(Divisor(Q/2) + Divisor(oo));
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
u := b[1];
phi := ProjectiveMap([u,v,1]);
E_new := Image(phi);
phi := Restriction(phi, ProjectiveClosure(C), D);
phi := Restriction(phi, ProjectiveClosure(C), E_new);
phi := Restriction(phi, E3, D);
phi := Restriction(phi, E3, E_new);
Degree(phi);
E_new;
DefiningEquation(AffinePatch(E_new,1));
RR;
RR, mp_RR := RiemannRochSpace(4*Divisor(Q/2) + 4*Divisor(oo));
Dimension(RR);
SingularPoints(E_new);
pts;
$pts;
#pts;
Q/2;
u;
Support(Divisor(v));
pts;
RR;
mp;
mp_RR;
v @@ mp_RR;
b;
b := Basis(RR);
b := [mp_RR(el) : el in b];
b[1];
b[1] @@ mp_RR;
Parent(b[1]);
Parent(v);
Parent(b[1]) eq Parent(v);
RR, mp_RR := RiemannRochSpace(4*Divisor(Q/2) + 4*Divisor(oo));
v^2 @@ mp_RR;
Support(Divisor(v));
Q/2;
RR, mp_RR := RiemannRochSpace(4*Divisor(-(Q/2)) + 4*Divisor(oo));
v^2 @@ mp_RR;
v @@ mp_RR;
(v @@ mp_RR)^2;
Support(Divisor(v));
-(Q/2);
(v^2) @@ mp_RR;
-Q/2;
-(Q/2);
u;
E_new;
DefiningEquation(AffinePatch(E_new,1));
F := DefiningEquation(AffinePatch(E_new,1));
R<x,y> := Parent(F);
G := Evaluate(F, [x, y^2]);
G;
Support(Divisor(v));
Support(Divisor(u));
RR, mp_RR := RiemannRochSpace(Divisor(-(Q/2)) + Divisor(oo));
b := Basis(RR);
b := [mp_RR(el) : el in b];
b;
u := b[1];
Support(Divisor(v));
Support(Divisor(u));
phi := ProjectiveMap([u,v,1]);
E_new := Image(phi);
phi := Restriction(phi, E3, E_new);
assert Degree(phi) eq 1;
E_new;
F := DefiningEquation(AffinePatch(E_new,1));
R<x,y> := Parent(F);
G := Evaluate(F, [x, y^2]);
G
;
SingularPoints(G);
X3 := Curve(AffineSpace(BaseRing(Parent(G)),3),G);
X3 := Curve(AffineSpace(BaseRing(Parent(G)),2),G);
X3_aff := X3;
X3 := ProjectiveClosure(X3_aff);
X3;
Genus(X_3);
Genus(X3);
DixmierOhnoInvariants(DefiningEquations(X3)[1]);
I := DixmierOhnoInvariants(DefiningEquations(X3)[1]);
I, W := DixmierOhnoInvariants(DefiningEquations(X3)[1]);
WPSNormalize(W, I);
fs;
printf "%m", X3;